\documentclass[a4paper,12pt]{report}

\usepackage{alltt, fancyvrb, url}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{wrapfig}
\usepackage{algorithmic}
\usepackage[utf8]{inputenc}
\usepackage{fontenc}
\usepackage{amsmath,stmaryrd,mathtools,algorithm}
\usepackage{amssymb}
\usepackage{float}
\usepackage{hyperref}

% Remove option to use English naming
\usepackage[italian]{cleveref}

% Questo commentalo se vuoi scrivere in inglese.
\usepackage[italian]{babel}

\title{Meta-relazione per\\``Programmazione ad Oggetti''}
 
\author{Giovanni Di Santi}
\date{\today}


\begin{document}
 
\maketitle

\begin{abstract}
Questo documento è una relazione di meta livello, ossia una relazione che spiega come scrivere la relazione.
%
Lo scopo di questo documento è quello di aiutare gli studenti a comprendere quali punti trattare nella loro relazione, ed in che modo farlo, evitando di perdere del tempo prezioso in prolisse discussioni di aspetti marginali tralasciando invece aspetti di maggior rilievo.
%
Per ciascuna delle sezioni del documento sarà fornita una descrizione di ciò che ci si aspetta venga prodotto dal team di sviluppo, assieme ad un elenco (per forza di cose non esaustivo) di elementi che \emph{non} dovrebbero essere inclusi.

Il modello della relazione segue il processo tradizionale di ingegneria del software fase per fase (in maniera ovviamente semplificata).
%
La struttura della relazione non è indicativa ma \textit{obbligatoria}.
%
Gli studenti dovranno produrre un documento che abbia la medesima struttura, non saranno accettati progetti la cui relazione non risponda al requisito suddetto.
%
Lo studente attento dovrebbe sforzarsi di seguire le tappe suggerite in questa relazione anche per l'effettivo sviluppo del progetto: oltre ad una considerevole semplificazione del processo di redazione di questo documento, infatti, il gruppo beneficerà di un processo di sviluppo più solido e collaudato, di tipo top-down.

La meta-relazione verrà fornita corredata di un template \LaTeX{} per coloro che volessero cimentarsi nell'uso.
%
L'uso di \LaTeX{} è vantaggioso per chi ama l'approccio ``what you mean is what you get'', ossia voglia disaccoppiare il contenuto dall'effettivo rendering del documento, accollando al motore \LaTeX{} l'onere di produrre un documento gradevole con la struttura ed il contenuto forniti.
%
Chi non volesse installare l'ambiente di compilazione in locale può valutare l'utilizzo dell'applicazione web \href{https://www.overleaf.com/}{Overleaf}.
%
L'eventuale utilizzo di \LaTeX{} non è fra i requisiti, non è parte del corso di Programmazione ad Oggetti, e non sarà ovviamente valutato. I docenti accetteranno qualunque relazione in formato standard Portable Document Format (pdf), indipendentemente dal software con cui tale documento sarà redatto.
\end{abstract}

\tableofcontents

\chapter{Analisi}

\section{Requisiti}

Il gruppo si pone come obiettivo quello di realizzare un keepass per salvare
in modo sicuro le password. Al momento i keepass desktop più usati sono
\href{https://keepass.info/}{keepass2} e \href{https://keepassxc.org/}{keepassxc}.

\subsubsection{Requisiti funzionali}
\begin{itemize}
  \item Gestione account con possibilità di suddividere gli account in gruppi.
  \item Funzione per generare password e nickname in maniera causale.
  \item Import ed export del database in XML e in un formato simile a KDBX.
  \item Controllo robustezza password al momento dell'inserimento
  \item Salvataggio dei dati in un database locale criptato con algoritmi a scelta
  \item Sezione Statistics che mostra le statistiche relative al proprio database (Es. il numero di account salvati)
\end{itemize}

\subsubsection{Requisiti non funzionali}
\begin{itemize}
	\item bho
\end{itemize}

\section{Analisi e modello del dominio}

TODO

\begin{figure}[h]
\centering{}
\includegraphics[width=\textwidth]{analysis}
\caption{rappresentazione UML dell'analisi del progetto}
\end{figure}

\chapter{Design}

\section{Architettura}

Per la realizzazione di KeePassJ abbiamo scelto di utilizzare il pattern architetturale
Model-View-Controller (MVC).

TODO: Inserire schema UML MVC.

\section{Design dettagliato}

TODO: Spiegare a grandi linee

\section*{Giovanni Di Santi}

Il mio compito principale del progetto è stato quello di gestire la parte crittografica e
definire la struttura dell'header del database.

\subsection*{CryptoCipher}

\textbf{CryptoCipher} è l'interfaccia che descrive i metodi necessari per effettuare
l'encryption e la decryption di un array di \texttt{byte}.\\
Ogni implementazione disponibile di questa interfaccia è un
\href{https://web.cs.ucdavis.edu/~rogaway/papers/ad.pdf}{AEAD Cipher} 
(Authenticated Encryption with Associated Data).\\
Ho scelto questo schema di encryption per rendere il database resistente ad 
attacchi del tipo \textbf{CCA} (Chosen Ciphertext Attack), cifrando il contenuto del
database e autenticando sia il contenuto che l'header (Associated Data).
\begin{figure}[h]
\centering{}
\includegraphics[width=\textwidth]{crypto-cipher}
\caption{rappresentazione UML del pattern factory per creare un CryptoCipher}
\end{figure}
Attualmente i cipher disponibili sono:
\begin{itemize}
  \item \href{https://tools.ietf.org/html/rfc7539}{ChaCha20-Poly1305}.
  \item \href{https://csrc.nist.gov/publications/detail/sp/800-38d/final}{AES-GCM}.
  \item \href{https://tools.ietf.org/html/draft-mcgrew-aead-aes-cbc-hmac-sha2-05}{AES-256-CBC-HMAC-SHA-512}.
\end{itemize}

Esistono due \texttt{abstract class} diverse per implementare un \textbf{CryptoCipher},
poiché la costruzione di \textbf{AES} che sarebbe \texttt{AES-256-CBC-HMAC-SHA-512} è manuale,
mentre \textbf{ChaCha20-Poly1305} e \textbf{AES-GCM} sono implementate direttamente in openjdk11.
La classe astratta \textbf{AEADAES}, permette di essere estesa per costruire altri
cryptosystem come \texttt{AES-192-CBC-HMAC-SHA-384}, tuttavia ho deciso di estendere
solo lo schema più sicuro.\\
Nonostante i dati da cifrare e decifrare sono nella pratica degli \{Input,Output\}Stream,
non ho usato le classi \href{https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/crypto/CipherOutputStream.html}{CipherOutputStream}
e \href{https://docs.oracle.com/en/java/javase/11/docs/api/java.base/javax/crypto/CipherInputStream.html}{CipherInputStream}
per:
\begin{itemize}
  \item Rendere più semplice il suo utilizzo.
  \item Facilitare il testing delle varie implementazioni.
\end{itemize}

%Ho usato il design pattern factory per creare un \textbf{CryptoCipher} perché
%quando

\subsection*{KDF}

\textbf{KDF} (Key Derivation Function) è l'interfaccia che descrive i metodi necessari
e opzionali per generare una chiave simmetrica per cifrare/decifrare il database.\\
Gli algoritmi disponibili sono:
\begin{itemize}
  \item Argon2.
  \item Scrypt.
  \item PBKDF2.
\end{itemize}

\begin{figure}[h]
\centering{}
\includegraphics[width=\textwidth]{kdf}
\caption{rappresentazione UML del pattern factory per creare un KDF}
\end{figure}

\textbf{Argon2} e \textbf{Scrypt} estendono \textbf{KDFAdvanced} poiché i loro
algoritmi permettono di definire parametri extra come il paralellismo e la memoria usata
dal KDF. \textbf{PBKDF2} è un vecchio metodo per generare una chiave dalla password e
l'unico parametro configurabile è il numero di round che usa internamente, per questo
ho settato il campo \texttt{tweakable} a falso.

Per capire perché il pattern \texttt{Factory} è usato sia per creare \textbf{KDF}
e \textbf{CryptoCipher} bisogna prima analizzare il parsing dell'header e la relativa
encryption/decryption del database.

\subsection*{KDB}

Per progettare questa parte non ho usato le interfacce perché:
\begin{itemize}
  \item Ho solo una implementazione disponibile.
  \item Sono più flessibile quando devo cambiare la signature di un metodo, senza dover usare un IDE o un LSP per il refactoring.
  \item Principio \href{https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it}{YAGNI} e \href{https://en.wikipedia.org/wiki/KISS_principle}{KISS}.
\end{itemize}

\textbf{KDBHeader} è la classe che si occupa di:
\begin{itemize}
  \item Parsare l'header (Lettura).
  \item Configurare i vari parametri (Scrittura).
\end{itemize}

\textbf{KDB} è la classe che tramite il \textbf{KDBHeader} si occupa di cifrare/decifrare
dati arbitrari.
Il pattern factory per \textbf{CryptoCipher} e \textbf{KDF} è utile quando in \textbf{KDB}
si effettua l'operazione \texttt{encrypt} e \texttt{decrypt}. I metodi richiedono
a \textbf{KDBHeader} il valore (String) del \texttt{Cipher} e del \texttt{KDF} che viene
passato come parametro di \{Cipher,KDF\}Factory.create() per generare l'oggetto
richiesto.
I due metodi pubblici principali di \textbf{KDB} sono:
\begin{itemize}
  \item \texttt{write}: che esegue l'encryption dell'array di byte in input e lo scrive sul file.
  \item \texttt{read}: che legge il file e lo decrypta. Questo metodo lancia un
    \texttt{IOException} se il file non esiste o un \texttt{AEADBadTagException} quando il file è corrotto.
    Il file può risultare corrotto o perché la password è sbagliata o perché è stato effettivamente manipolato.
    Non lancio tipi diversi di eccezioni (es. \texttt{BadPaddingException}) in base a vari tipi di errore,
    per evitare vari tipi di attacchi (praticamente difficili, ma teoricamente possibili) come
    il padding oracle.
\end{itemize}

\begin{figure}[h]
\centering{}
\includegraphics[width=\textwidth]{kdb}
\caption{rappresentazione UML di KDB}
\end{figure}

\chapter{Sviluppo}
\section{Testing automatizzato}

Durante lo sviluppo del nostro progetto abbiamo utilizzato \texttt{Junit} per
testare il corretto funzionamento delle varie classi.
\textbf{Funzionalità testate automaticamente}:
\begin{itemize}
  \item \textit{CryptoCipher}: viene testato il corretto comportamento dei vari cipher utilizzando lo specifico \texttt{Factory}.
  \item \textit{KDF}: vengono testate le varie KDF utilizzando lo specifico \texttt{Factory}.
  \item \textit{Crypto Util}: test di varie utility per crittografia, come il PKCS\#7 padding e SHA256.
  \item \textit{KDBHeader}: viene testato il corretto funzionamento del \textbf{KDBHeader}, settando vari parametri e controllando il corretto funzionamento dei getter.
  \item \textit{KDB}: test sulla scrittura e lettura di diverse combinazioni di \texttt{cipher} e \texttt{KDF}.
\end{itemize}

I test vengono eseguiti anche in remoto tramite l'apposita \textit{bitbucket pipelines} che
esegue la build del progetto e lancia i vari test.

\section{Metodologia di lavoro}

TODO.

\section{Note di sviluppo}

\section*{Giovanni Di Santi}

\begin{itemize}
  \item \textit{javax.crypto}: usata per lavorare con Cipher, KDF, e MessageDigest.
  \item \textit{Stream}: usata per manipolare l'header in modo efficace ed elegante.
  \item \textit{Libreria Google Guava}: lavorare con i byte array in java non è comodo. Questa libreria ha varie classi per semplificare
    il lavoroi tra cui \href{https://guava.dev/releases/19.0/api/docs/com/google/common/primitives/Bytes.html}{Bytes}.
  \item \textit{ByteBuffer}: per convertire in little endian i bytes, i Data\{Input,Output\}Stream in java lavorano solo in big-endian.
  \item \textit{Libreria Argon2 e Scrypt}: Questi due KDF non erano disponibili dentro \texttt{javax.crypto}.
  \item \textit{Libreria Apache Commons}: per convertire byte array in formato esadecimale.
\end{itemize}

\chapter{Commenti finali}

In quest'ultimo capitolo si tirano le somme del lavoro svolto e si delineano eventuali sviluppi 
futuri.

\textit{Nessuna delle informazioni incluse in questo capitolo verrà utilizzata per formulare la valutazione finale}, a meno che non sia assente o manchino delle sezioni obbligatorie.
%
Al fine di evitare pregiudizi involontari, l'intero capitolo verrà letto dai docenti solo dopo aver formulato la valutazione.

\section{Autovalutazione e lavori futuri}

\textbf{È richiesta una sezione per ciascun membro del gruppo, obbligatoriamente}.
%
Ciascuno dovrà autovalutare il proprio lavoro, elencando i punti di forza e di debolezza in quanto prodotto.
Si dovrà anche cercare di descrivere \emph{in modo quanto più obiettivo possibile} il proprio ruolo all'interno del gruppo.
Si ricorda, a tal proposito, che ciascuno studente è responsabile solo della propria sezione: non è un problema se ci sono opinioni contrastanti, a patto che rispecchino effettivamente l'opinione di chi le scrive.
Nel caso in cui si pensasse di portare avanti il progetto, ad esempio perché effettivamente impiegato, o perché sufficientemente ben riuscito da poter esser usato come dimostrazione di esser capaci progettisti, si descriva brevemente verso che direzione portarlo.

\section{Difficoltà incontrate e commenti per i docenti}

Questa sezione, \textbf{opzionale}, può essere utilizzata per segnalare ai docenti eventuali problemi o difficoltà incontrate nel corso o nello svolgimento del progetto, può essere vista come una seconda possibilità di valutare il corso (dopo quella offerta dalle rilevazioni della didattica) avendo anche conoscenza delle modalità e delle difficoltà collegate all'esame, cosa impossibile da fare usando le valutazioni in aula per ovvie ragioni.
%
È possibile che alcuni dei commenti forniti vengano utilizzati per migliorare il corso in futuro: sebbene non andrà a vostro beneficio, potreste fare un favore ai vostri futuri colleghi.
%
Ovviamente \textit{il contenuto della sezione non impatterà il voto finale}.

\appendix
\chapter{Guida utente}

Capitolo in cui si spiega come utilizzare il software. Nel caso in cui il suo uso sia del tutto 
banale, tale capitolo può essere omesso.
%
A tal riguardo, si fa presente agli studenti che i docenti non hanno mai utilizzato il software 
prima, per cui aspetti che sembrano del tutto banali a chi ha sviluppato l'applicazione possono non 
esserlo per chi la usa per la prima volta.
%
Se, ad esempio, per cominciare una partita con un videogioco è necessario premere la barra 
spaziatrice, o il tasto ``P'', è necessario che gli studenti lo segnalino.

\subsection*{Elementi positivi}

\begin{itemize}
 \item Si istruisce in modo semplice l'utente sull'uso dell'applicazione, eventualmente facendo uso di schermate e descrizioni.
\end{itemize}

\subsection*{Elementi negativi}
\begin{itemize}
 \item Si descrivono in modo eccessivamente minuzioso tutte le caratteristiche, anche minori, del software in oggetto.
 \item Manca una descrizione che consenta ad un utente qualunque di utilizzare almeno le funzionalità primarie dell'applicativo.
\end{itemize}

\bibliographystyle{abbrv}
\bibliography{template}

\end{document}

